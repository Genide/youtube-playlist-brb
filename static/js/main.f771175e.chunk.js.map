{"version":3,"sources":["Components/SMPTE_Color_Bars.svg","Controller/PlaylistRetriever.ts","Utilities/Utilities.ts","Components/YoutubePlaylistSnippet.tsx","Components/ConfigForm.tsx","Controller/Beeper.ts","Components/TestPattern.tsx","Components/PlaylistPlayer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","YTPlaylistRetriever","apiKey","_apiKey","this","playlistId","list","token","_getPlaylistVideoPage","temp","error","Error","message","push","items","nextPageToken","GetPlaylistVideos","map","video","contentDetails","videoId","filter","id","pageToken","url","URL","searchParams","append","fetch","href","headers","response","json","playlist","RandomizeOrder","array","temporaryValue","randomIndex","currentIndex","length","shuffledArray","Math","floor","random","GetPlaylistObject","YTApiKey","a","request","find","YoutubePlaylistSnippet","state","props","snippet","style","display","flexGrow","padding","src","thumbnails","default","alt","paddingLeft","title","channelTitle","description","Component","ConfigForm","YTListId","YoutubeApiKey","initialValues","youtubeListId","loadingText","validate","values","errors","getYTList","setState","currentPlaylist","onSubmit","setSubmitting","validateOnChange","formik","handleSubmit","borderStyle","borderWidth","width","minWidth","TextField","label","value","onChange","handleChange","onBlur","handleBlur","name","helperText","fullWidth","disabled","isSubmitting","Button","type","defaultProps","Beeper","beepVolume","_context","_oscillator","_gain","_beepVolume","AudioContext","createOscillator","frequency","createGain","connect","destination","gain","start","duration","StartBeep","setTimeout","StopBeep","TestPattern","height","hidden","TestPatternImage","position","top","left","fontSize","color","transform","backgroundColor","textAlign","text","PlaylistPlayer","currentVideoId","IsVideoPlaying","IsLoadingVideo","_beeper","_currentVideoIndex","loadCurrentPlaylistVideo","newState","containerClassName","opts","playerVars","autoplay","controls","fs","rel","modestbranding","onPlay","onPlayerStart","onEnd","loadNextPlaylistVideo","App","LoadingText","_playlistRetriever","AppConfig","window","location","get","search","onMount","GetPlaylistVideoIds","console","log","newHref","navigator","clipboard","writeText","alert","onConfigFormSubmit","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.f771175e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/SMPTE_Color_Bars.bba5813e.svg\";","import { IPlaylistItem, IPlayListItemListResponse } from \"../Interfaces/YTInterfaces\";\n\n\nexport default class YTPlaylistRetriever {\n    private _apiKey: string;\n    /**\n     * Creates a YTPlaylistRetriever\n     * @param apiKey The youtube v3 api key\n     */\n    constructor(apiKey: string) {\n        this._apiKey = apiKey;\n    }\n\n    /**\n     * Returns a list of youtube videos\n     * @param playlistId The youtube play list id\n     */\n    public async GetPlaylistVideos(playlistId: string): Promise<IPlaylistItem[]> {\n        let list: IPlaylistItem[] = [];\n        let token = '';\n\n        do {\n            let temp = await this._getPlaylistVideoPage(playlistId, token);\n            if (temp.error) {\n                throw new Error(temp.error.message);\n            }\n            list.push(...temp.items);\n            token = temp.nextPageToken ?? \"\";\n        } while (token !== \"\")\n\n        return list;\n    }\n\n    /**\n     * Returns a list of youtube video IDs\n     * @param playlistId The youtube playlist ID\n     */\n    public async GetPlaylistVideoIds(playlistId: string): Promise<string[]> {\n        let list = await this.GetPlaylistVideos(playlistId);\n        return list.map(video => video.contentDetails?.videoId ?? \"\")\n            .filter(id => id !== '');\n    }\n\n    /**\n     * Gets a page of videos from the youtube playlist\n     * @param playlistId The youtube playlist ID\n     * @param pageToken The page token for the next video\n     */\n    private async _getPlaylistVideoPage(playlistId: string, pageToken?: string): Promise<IPlayListItemListResponse> {\n        let url = new URL(\"https://www.googleapis.com/youtube/v3/playlistItems\");\n        url.searchParams.append('part', 'contentDetails');\n        url.searchParams.append('playlistId', playlistId);\n        url.searchParams.append('key', this._apiKey);\n        url.searchParams.append('maxResults', '50');\n        if (pageToken) url.searchParams.append('pageToken', pageToken);\n        \n        let response = await fetch(url.href, {\n            headers: {\n                'Accept': 'application/json',\n            }\n        });\n        let playlist: IPlayListItemListResponse = await response.json();\n\n        return playlist;\n    }\n}","import { IPlaylist, IPlaylistListResponse } from \"../Interfaces/YTInterfaces\";\n\n/**\n * Creates a new array and randomizes the order of the elements\n * @param array Input array\n */\nexport function RandomizeOrder<T> (array: T[]): T[] {\n    let currentIndex = array.length, temporaryValue, randomIndex;\n    let shuffledArray = [...array];\n\n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = shuffledArray[currentIndex];\n      shuffledArray[currentIndex] = shuffledArray[randomIndex];\n      shuffledArray[randomIndex] = temporaryValue;\n    }\n  \n    return shuffledArray;\n}\n\nexport async function GetPlaylistObject(playlistId: string, YTApiKey: string): Promise<IPlaylist | undefined> {\n  let url = new URL('https://www.googleapis.com/youtube/v3/playlists');\n  url.searchParams.append('part', 'id');\n  url.searchParams.append('id', playlistId);\n  url.searchParams.append('key', YTApiKey);\n  let request = await fetch(url.href, {\n      headers: {\n          \"Accept\": \"application/json\"\n      }\n  })\n\n  let json: IPlaylistListResponse = await request.json();\n  let playlist = json.items.find(playlist => playlist.id === playlistId)\n\n  return playlist;\n}","import React, { Component, Fragment } from 'react'\nimport { IPlaylist } from '../Interfaces/YTInterfaces'\n\ninterface Props {\n    playlist?: IPlaylist\n}\ninterface State {\n    \n}\n\nexport default class YoutubePlaylistSnippet extends Component<Props, State> {\n    state = {}\n\n    render() {\n        if (!this.props.playlist) return <Fragment />;\n        if (!this.props.playlist.snippet) return <Fragment />;\n\n        return (\n            <div style={{display: \"flex\", flexGrow: 1, padding: '1em'}}>\n                <div>\n                    <img src={this.props.playlist.snippet.thumbnails.default.url} alt='thumbnail'/>\n                </div>\n                <div style={{paddingLeft: '1em'}}>\n                    <table >\n                        <tbody>\n                            <tr>\n                                <th>Playlist Title</th>\n                                <td>{this.props.playlist.snippet.title}</td>\n                            </tr>\n                            <tr>\n                                <th>Channel Name</th>\n                                <td>{this.props.playlist.snippet.channelTitle}</td>\n                            </tr>\n                            <tr>\n                                <th>Playlist Description</th>\n                                <td>{this.props.playlist.snippet.description}</td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        );\n    }\n}\n","import React, { Component } from 'react'\nimport { Formik } from 'formik';\nimport { IPlaylist, IPlaylistListResponse } from '../Interfaces/YTInterfaces'\nimport { Button, TextField } from '@material-ui/core';\nimport YoutubePlaylistSnippet from './YoutubePlaylistSnippet';\n\ninterface Props {\n    YoutubeApiKey: string,\n    onSubmit: IOnSubmit\n}\ninterface State {\n    currentPlaylist?: IPlaylist;\n}\n\ninterface IOnSubmit {\n    (values: onSubmitParameters): void\n}\n\nexport interface onSubmitParameters {\n    youtubeListId: string,\n    loadingText: string\n}\n\nexport default class ConfigForm extends Component<Props, State> {\n    static defaultProps = {\n        onSubmit: () => { }\n    }\n\n    state: State = {}\n\n    private async getYTList(YTListId: string): Promise<IPlaylist | undefined> {\n        let url = new URL('https://www.googleapis.com/youtube/v3/playlists');\n        url.searchParams.append('part', 'snippet');\n        url.searchParams.append('id', YTListId);\n        url.searchParams.append('key', this.props.YoutubeApiKey);\n        let request = await fetch(url.href, {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        })\n\n        let json: IPlaylistListResponse = await request.json();\n        let playlist = json.items.find(playlist => playlist.id === YTListId)\n\n        return playlist;\n    }\n\n    render() {\n        return (\n            <div style={{ display: \"flex\", padding: '1em' }}>\n                <Formik\n                    initialValues={{\n                        youtubeListId: '',\n                        loadingText: 'BE RIGHT BACK!',\n                    }}\n                    validate={async values => {\n                        const errors: any = {};\n                        if (!values.youtubeListId) {\n                            errors.youtubeListId = 'Required';\n                        } else {\n                            let temp = await this.getYTList(values.youtubeListId);\n                            if (!temp) {\n                                errors.youtubeListId = 'Invalid playlist ID'\n                            }\n                            this.setState({ currentPlaylist: temp });\n                        }\n\n                        return errors;\n                    }}\n                    onSubmit={(values, { setSubmitting }) => {\n                        this.props.onSubmit(values);\n                        setSubmitting(false);\n                    }}\n                    validateOnChange={false}\n                >\n                    {(formik) => {\n                        return (\n                            <form onSubmit={formik.handleSubmit} style={{ borderStyle: 'groove', borderWidth: '5px', padding: '1em', width: '25%', minWidth: '500px' }}>\n                                <TextField\n                                    label='Youtube Playlist ID'\n                                    value={formik.values.youtubeListId}\n                                    onChange={formik.handleChange}\n                                    onBlur={formik.handleBlur}\n                                    name='youtubeListId'\n                                    error={formik.errors.youtubeListId ? true : false}\n                                    helperText={formik.errors.youtubeListId ?? 'Enter a youtube playlist ID'}\n                                    fullWidth\n                                    disabled={formik.isSubmitting}\n                                />\n                                <br />\n                                <br />\n                                <br />\n                                <TextField\n                                    label='Loading Text'\n                                    value={formik.values.loadingText}\n                                    onChange={formik.handleChange}\n                                    onBlur={formik.handleBlur}\n                                    name='loadingText'\n                                    error={formik.errors.loadingText ? true : false}\n                                    helperText={formik.errors.loadingText ?? 'Displayed while loading the next video in the playlist'}\n                                    fullWidth\n                                    disabled={formik.isSubmitting}\n                                />\n                                <br />\n                                <br />\n                                <Button type='submit' disabled={formik.isSubmitting}>\n                                    Create Link\n                                </Button>\n                            </form>\n                        )\n                    }}\n                </Formik>\n                <YoutubePlaylistSnippet playlist={this.state.currentPlaylist} />\n            </div>\n        )\n    }\n}\n","\nexport default class Beeper {\n    private _context: AudioContext\n    private _oscillator: OscillatorNode\n    private _gain: GainNode\n    private _beepVolume: number;\n\n    /**\n     * \n     * @param beepVolume A value from 0 - 1. Sets the volume of the beep. By default, this is .1.\n     */\n    constructor(beepVolume: number = .1) {\n        this._beepVolume = beepVolume;\n        this._context = new AudioContext();\n        this._oscillator = this._context.createOscillator();\n        this._oscillator.frequency.value = 1000;\n        this._gain = this._context.createGain();\n        this._oscillator.connect(this._gain);\n        this._gain.connect(this._context.destination);\n        this._gain.gain.value = 0;\n        this._oscillator.start(0);\n    }\n\n    public Beep(duration: number = 500){\n        this.StartBeep()\n        setTimeout(() => {\n            this.StopBeep();\n        }, (duration));\n    }\n\n    public StartBeep() {\n        this._gain.gain.value = this._beepVolume; // Sets the volume of the beep\n    }\n\n    public StopBeep() {\n        this._gain.gain.value = 0;\n    }\n}","import React, { Component } from 'react'\nimport TestPatternImage from './SMPTE_Color_Bars.svg'\n\ninterface Props {\n    hidden: boolean,\n    text: string,\n}\ninterface State {\n    \n}\n\nexport default class TestPattern extends Component<Props, State> {\n    static defaultProps = {\n        hidden: false,\n        text: \"\"\n    }\n    \n    state = {}\n\n    render() {\n        let containerStyle: React.CSSProperties = {\n            width: '100%',\n            height: '100%',\n        }\n\n        let overlayTextStyle: React.CSSProperties = {\n            position: 'absolute',\n            top: '50%',\n            left: '50%',\n            fontSize: '150px',\n            color: \"white\",\n            transform: 'translate(-50%,-50%)',\n            backgroundColor: \"black\",\n            textAlign: 'center'\n        }\n\n        return (\n            <div style={{...containerStyle, display: this.props.hidden ? \"none\": \"flex\"}}>\n                <img src={TestPatternImage} alt=\"\" style={{width: '100%'}} />\n                <div style={overlayTextStyle}>\n                    {this.props.text}\n                </div>\n            </div>\n        )\n    }\n}\n","import React, { Component, Fragment } from 'react'\nimport YTPlayer, { Options } from 'react-youtube';\nimport Beeper from '../Controller/Beeper';\nimport TestPattern from './TestPattern'\n\ninterface Props {\n    playlist: string[];\n    loadingText: string;\n}\ninterface State {\n    currentVideoId: string;\n    IsVideoPlaying: boolean;\n    IsLoadingVideo: boolean;\n}\n\nexport default class PlaylistPlayer extends Component<Props, State> {\n    static defaultProps = {\n        playlist: [],\n        loadingText: ''\n    }\n    state: State = {\n        currentVideoId: '',\n        IsVideoPlaying: false,\n        IsLoadingVideo: true\n    }\n    private _beeper: Beeper;\n    private _currentVideoIndex: number;\n\n    constructor(props: Props) {\n        super(props);\n        this._beeper = new Beeper(.1);\n        this._currentVideoIndex = 0;\n    }\n\n    componentDidMount() {\n        this.loadCurrentPlaylistVideo();\n    }\n\n    onPlayerStart() {\n        this.setState({\n            IsVideoPlaying: true,\n            IsLoadingVideo: false\n        });\n        this._beeper.StopBeep();\n    }\n\n    loadNextPlaylistVideo() {\n        this._currentVideoIndex++;\n        this.loadCurrentPlaylistVideo();\n    }\n\n    loadCurrentPlaylistVideo() {\n        let newState = {\n            IsVideoPlaying: false,\n            IsLoadingVideo: false,\n            currentVideoId: ''\n        }\n        if (this._currentVideoIndex < this.props.playlist.length) {\n            newState.currentVideoId = this.props.playlist[this._currentVideoIndex];\n            newState.IsLoadingVideo = true;\n            this._beeper.StartBeep();\n        }\n\n        this.setState(newState);\n    }\n\n    render() {\n        if (this.props.playlist.length === 0) return <Fragment />\n\n        const YTPlayerOpts: Options = {\n            height: '100%',\n            width: '100%',\n            playerVars: {\n                autoplay: 1,\n                controls: 0, // Hide the player controls\n                fs: 0, // Hide the fullscreen button\n                rel: 0, // Disable showing related videos after a video is finished playing\n                modestbranding: 1\n            }\n        }\n\n        return (\n            <div style={{height: 'inherit'}}>\n                <div hidden={!this.state.IsVideoPlaying} style={{height: 'inherit'}}>\n                    <YTPlayer\n                        containerClassName='YTPlayerContainer'\n                        videoId={this.state.currentVideoId}\n                        opts={YTPlayerOpts}\n                        onPlay={() => this.onPlayerStart()}\n                        onEnd={() => this.loadNextPlaylistVideo()}\n                    />\n                </div>\n                <TestPattern hidden={!this.state.IsLoadingVideo} text={this.props.loadingText}/>\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react'\nimport './App.css';\nimport YTPlaylistRetriever from './Controller/PlaylistRetriever';\nimport AppConfig from './AppConfig.json';\nimport { GetPlaylistObject, RandomizeOrder } from './Utilities/Utilities';\nimport ConfigForm, { onSubmitParameters } from './Components/ConfigForm';\nimport PlaylistPlayer from './Components/PlaylistPlayer';\n\n\ninterface Props {\n    \n}\ninterface State {\n    currentVideoId: string;\n    IsVideoPlaying: boolean;\n    IsLoadingVideo: boolean;\n    LoadingText: string;\n    playlist: string[];\n    playlistId: string;\n}\n\nexport default class App extends Component<Props, State> {\n    state = {\n        currentVideoId: '',\n        IsVideoPlaying: false,\n        IsLoadingVideo: true,\n        LoadingText: '',\n        playlist: [],\n        playlistId: ''\n    }\n    private _playlistRetriever: YTPlaylistRetriever;\n\n    constructor(props: Props) {\n        super(props);\n        this._playlistRetriever = new YTPlaylistRetriever(AppConfig.apiKey);\n\n        // Use PL4o29bINVT4EG_y-k5jGoOu3-Am8Nvi10 for a super super long list\n        // Use PLWXWbr9ex3iVqtmHSJ0OIeEnD2hOZnp2Q for xenoblade chronicles music\n        // Use PLxV_ER5SmeVYYSKfzplwqoQzmYWMEidIV for a super short list\n        // Use PLaetSIDm3F73cpqVlmsQgrpX3GV_NwU1T for a sample montage list \n        let url = new URL(window.location.href);\n        this.state.playlistId = url.searchParams.get('list') ?? AppConfig.playlistId ?? '';\n        this.state.LoadingText = url.searchParams.get('loadingText') ?? AppConfig.loadingText ?? '';\n\n        url.search = '';\n    }\n\n    componentDidMount() {\n        this.onMount();\n    }\n\n    async onMount() {\n        if (!this.state.playlistId) return;\n        \n        let playlist = await GetPlaylistObject(this.state.playlistId, AppConfig.apiKey);\n        if (!playlist) {\n            this.setState({playlistId: '', playlist: []});\n            return;\n        }\n\n        try {\n            let temp = await this._playlistRetriever.GetPlaylistVideoIds(this.state.playlistId);\n            this.setState({playlist: RandomizeOrder(temp)});\n        } catch (error) {\n            console.error(error);\n        }\n    }\n\n    onConfigFormSubmit(values: onSubmitParameters) {\n        console.log(values);\n        let url = new URL(window.location.href);\n        url.search = ''; // Get rid of all query parameters\n        url.searchParams.append('list', values.youtubeListId);\n        url.searchParams.append('loadingText', values.loadingText);\n        let newHref = url.href\n        navigator.clipboard.writeText(newHref);\n        alert(`The link has been copied to your clipboard. Redirecting you to your new page.`);\n        window.location.href = url.href;\n    }\n\n    render() {\n        return (\n            <div style={{height: 'inherit'}}>\n                {this.state.playlist.length > 0 \n                    ? <PlaylistPlayer playlist={this.state.playlist} loadingText={this.state.LoadingText} /> : '' }\n                {!this.state.playlistId\n                    ? <ConfigForm YoutubeApiKey={AppConfig.apiKey} onSubmit={values => this.onConfigFormSubmit(values)} />\n                    : ''}\n            </div>\n        );\n    } \n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}